# 面试题汇总

* [前端进阶指南 ProcessOn](https://www.processon.com/view/link/61c53fb31efad45a2b42afd9#map)
* [大厂面试题每日一题](https://q.shanyue.tech/fe/)
* [56个 JavaScript 高级手写知识点](https://juejin.cn/post/7023906112843808804#comment)



# 手写题

* [x] 防抖和节流
* [x] 数组去重（三种方式）
* [x] call()、apply() 和 bind()
* [x] Promise
* [x] new
* [x] instanceof





# 面向对象

> * 构造函数
> * 原型（`prototype`）
> * 原型对象
> * 实例
> * 隐式原型（`[[Prototype]]` / `__proto__`）
> * 原型链
> * `instanceof`
> * `new`
> * 继承
> * `Object.create()`



## 名词

**实例/对象（引用类型的实例和自定义类型的实例）身上默认可以使用的属性和方法**

> `var instance = new Object()`
>
> `instance.`

1. `__proto__`

2. `constructor`（原型对象属性）

3. `hasOwnProperty`（原型对象方法，继承自 Object）

4. `isPrototypeOf`（原型对象方法，继承自 Object）

5. `propertyIsEnumable`（原型对象方法，继承自 Object）

6. `toLocaleString`（原型对象方法，继承自 Object）

7. `toString`（原型对象方法，继承自 Object）

8. `valueOf`（原型对象方法，继承自 Object）







## 知识点

1. 面向对象（OO）语言的共同点，都有类的概念。通过类可以创建任意多个具有相同属性和方法的对象。
2. ECMAScript 中没有类的概念，因此它的**对象**也与基于类的语言中的对象有所不同。
3. ECMAScript 把对象定义为：“无序**属性**的集合，其属性可以包含基本值、对象或函数”。
4. 每个对象都是基于一个引用类型创建的，也可以是自定义类型。
5. 引用类型的值（**对象**）是引用类型的一个**实例**。
6. 引用类型是一种数据结构，可以类比为类。
7. 对象属性在创建时都带有一些**特征值**，JavaScript 通过这些特征值来定义它们的行为。
8. 属性类型：有两种类型，数据属性和访问器属性。每种属性都有一些用来描述其行为的特性。这些特性是 JavaScript 内部使用的，不可以在 JavaScript 中直接访问它们。
9. 数据属性：[[Configurable]]、[[Enumerable]]、[[Writable]] 和 [[Value]]。直接在对象上定义的属性，这四个特性都被设置为 true。
10. `Object.defineProperty()`
11. 访问器属性：[[Configurable]]、[[Enumerable]]、[[Get]] 和 [[Set]]。不能直接定义访问器属性，必须使用 `Object.defineProperty()` 来定义。
12. 读取属性的特性：`Object.getOwnPropertyDescriptor()`
13. 【*1】创建对象 -- 工厂模式。思路：1. 创建一个对象；2. 往这个对象身上添加属性；3. 返回这个对象。缺点：无法识别对象的类型。
14. 【*2】创建对象 -- 构造函数模式。思路：1. 定义一个构造函数（函数名以大写开头的函数）；2. 使用 new 操作符创建构造函数的实例。使用 new 操作符调用构造函数：1. 创建一个对象；2. 将构造函数的作用域赋给新对象（将 this 指向这个新对象）；3. 执行构造函数中的代码（为新对象添加属性）；4. 返回这个新对象（如果构造函数没有返回对象类型，则返回这个新对象，否则返回构造函数的返回值）。优点：创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型（比如 Person 类型）。缺点：为了让实例共享（功能相同的）方法，需要将方法的定义放到构造函数外部（全局作用域中），从而破坏了程序的封装性质。
15. `instanceOf` 操作符，思考：为什么使用对象字面量重写了构造函数的原型（ `构造函数.prototype`）后，`instanceof` 操作符依然有效。 `instanceof` 的原理是什么。
16. 实例身上的 constructor 属性指向该实例的构造函数。
17. 【*3】创建对象 -- 原型模式。思路：利用函数的 `prototype` 属性，将实例共享的属性和方法定义到原型对象身上。优点：实例可以共享属性和方法。缺点：由于定义在原型上的属性和方法被所有实例所共享，所以有一个实例修改了某个属性将会影响到其他实例。不可以向构造函数传递参数。
18. 【1】每个函数都有一个 `prototype`（原型）属性。这个属性是一个指针，指向一个对象（原型对象），这个对象的用途是**包含可以由特定类型的所有实例共享的属性和方法**（包括 `constructor` 属性）。所以 `prototype` 所指向的对象，就是通过调用构造函数而创建的实例对象的**原型对象**。【2】所有原型对象都会自动获得一个 `constructor` 属性，这个属性包含一个指向 prototype 属性所在函数的指针。原型对象中的其他方法，则是从 Object 继承而来的。【3】当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（`__proto__`），指向构造函数的原型对象。
19. `构造函数.prototype.isPrototypeOf(实例)`，如果 `[[Prototype]] ` 指向调用 `isPrototypeOf()` 方法的对象，那么这个方法就返回 `true`（例如：`Person.prototype.isPrototypeOf(person)`）。
20. `Object.getPrototypeOf(实例)`，该方法返回 `[[Prototype]]` 的值，利用该方法，可以方便的取得一个对象的原型对象。
21. `实例.hasOwnProperty(属性)` ，该方法可以判断属性是在实例自身还是存在于原型对象身上。
22. `in`，有两种方式使用 `in` 操作符：单独使用和在 `for-in` 循环中使用。一个属性，不管是在实例身上还是在原型对象身上，只要实例可以访问该属性，则 `in` 操作符的结果为 `true`。
23. 【1】`for-in` 循环，返回的是所有能够通过对象访问的、**可枚举**的属性。**既包括实例属性，也包括原型中的属性**。【2】`Object.keys(实例)` / `Object.keys(构造函数.prototype)` 方法，该方法可以取得对象身上所有的**可枚举的实例属性**，返回一个包含所有可枚举属性的字符串数组。【3】`Object.getOwnPropertyNames(实例)` / `Object.getOwnPropertyNames(构造函数.prototype)` 方法，该方法可以取得**所有实例属性**，无论它是否可枚举。
24. 使用一个包含所有属性和方法的对象字面量来重写整个原型对象。这种方法会出现一个问题，原型对象中的 `constructor` 属性将不再指向原来的构造函数，而是指向 Object 构造函数。可以在原型对象中显示的将 `constructor` 属性的值设置为原来的构造函数，但是这样又会出现新的问题，即 `constructor` 属性变成可枚举属性（可以通过 `for-in` 循环获取）。可以通过 `Object.defineProperty()` 方法来定义 `constructor` 属性。
25. 【*4】创建对象 -- 组合使用构造函数模式和原型模式。思路：将实例的私有属性定义在构造函数中，将需要共享的属性和方法定义在原型对象中。
26. 【*5】创建对象 -- 动态原型模式。在构造函数中检查某个应该存在的方法是否有效，来决定是否需要初始化原型。
27. 【*6】创建对象 -- 寄生构造函数模式。思路：构造函数的形式与工厂模式一模一样（手动创建一个对象，往该对象身上添加属性和方法，最后返回该对象），与工厂模式不同的是该构造函数将会使用 `new` 操作符来调用。应用：在不向原生对象的原型上添加方法的前提下，创建出具有特殊方法的实例（例如，不向 `Array.prototype` 上添加方法，但是创建出来的数组却具有特殊的方法）。
28. 【*7】创建对象 -- 稳妥构造函数模式。思路：没有公共属性，其方法不引用 `this`，不使用 `new` 调用构造函数。必须通过实例的方法才能访问到属性。
29. 【*1】继承 -- 原型链。优点：可以轻松实现继承。缺点：【1】由于使用原型链实现继承的原理是将一个原型对象作为另一个类型的实例，所以原型对象会包含另一个类型的所有属性，又因为实例指向相同的原型对象，所以实例将共享原型身上的属性和方法（如果是引用类型的属性，则会容易出错）。【2】在创建子类型的实例时，无法向超类型的构造函数传递参数。
30. 构造函数、原型和实例的关系（原型链的基本概述）：每一个构造函数都有一个 prototype 属性指向它的原型对象，原型对象内部有一个 constructor 属性指向该原型对象的构造函数，通过 new 操作符调用构造函数可以创建实例，实例内部有一个 [[Prototype]] 指针，指向原型对象。假如让原型对象等于另一个类型的实例，那么此时的原型对象将包含一个指向另一个原型对象的内部指针，另一个原型对象也会包含一个指向另一个构造函数的指针。假如另一个原型对象又是另一个类型的实例，那么上述关系依然成立，如此关系层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。
31. 【*2】继承 -- 借用构造函数（伪造对象 / 经典继承）。思路：在子类型中使用 `call` 或 `apply` “借调”超类型的构造函数。优点：实例对象可以有独立的属性和方法。可以向超类型传递参数。缺点：必须将所有方法都定义在构造函数中，失去了函数的复用性。超类型原型中的属性和方法不能被子类型使用。
32. 【*3】继承 -- 组合继承（伪经典继承）。思路：将原型链和借用构造函数的技术组合在一起。使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，即通过在原型上定义方法实现了函数的复用，又能保证每个实例都有它自己的属性。优点：【1】每个实例可以有自己属性，也可以使用相同的方法。【2】在子类型中可以向超类型传递参数。
33. 【*4】继承 -- 原型式继承。思路：定义一个工厂函数，在这个函数内部先创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型对象，最后返回这个临时类型的一个新实例。从本质上讲，这个工厂函数式对传入的对象做了一次浅复制。
34. `Object.create()` 方法，规范化了原型式继承。该方法接收两个参数，并返回一个对象。第一个参数是作为返回对象的 `[[Prototype]]` 属性所指向的原型对象，第二个参数（可选）是一个为新对象定义额外属性的对象（与 `Object.defineProperties()` 方法的第二个参数格式相同）。在传入一个参数的情况下，`Object.create()` 的行为与上述的构造函数行为相同。
35. 【*5】继承 -- 寄生式继承。思路：在原型式继承的基础上，为新创建的对象扩展对象的属性和方法。应用：在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。
36. 【*6】继承 -- 寄生组合式继承。组合式继承存在的问题：在子类型的实例和实例的原型对象上都会存在超类型构造函数内的属性。思路：利用寄生式继承仅仅让子类型的原型内部的 `[[Prototype]]` 属性指向超类型的原型对象，而不是像组合式继承那样通过 `new` 操作符调用超类型构造函数，从而避免了子类型的原型上也存在超类型构造函数中的属性。
37. `Object.setPrototypeOf(实例, 原型对象)`，该方法允许修改任意指定实例的原型。
38. `super` 是指向当前对象原型的一个指针，实际上就是 `Object.getPrototypeOf(实例)` 的值。可以在简写的方法之内使用 `super` 引用来调用对象原型上的任何方法。在多级继承中，`super` 引用依然有效。
39. 在 ES6 之前，“方法”的概念可以理解为对象的函数属性。ES6 则正式做出了定义：方法是一个拥有 `[[HomeObject]]` 内部属性的函数，此内部属性指向该方法所属的对象。任何对 `super` 的引用都会使用 `[[HomeObject]]` 属性来判断要做什么。具体步骤：【1】在 `[[HomeObject]]` 上调用 `Object.getPrototypeOf()` 来获取对原型的引用；【2】在该原型上查找同名函数；【3】创建 `this` 绑定并调用该方法。







## 面试题

1. 如何理解**原型**？如何理解原型链？(掘金小册)
2. 如何自己实现一个 **instanceof** 运算符？（掘金小册）
5. 使用 **new** 操作符时会进行哪些操作？（[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new)）
6. 如何自己实现一个 **new** 操作符？（[掘金](https://juejin.cn/post/6844903976081555470)）
7. JavaScript 中实现**继承**有哪些方式？（[掘金](https://juejin.cn/post/6844903976081555470)）
8. **ES5/ES6 继承**除了形式上还有哪些区别？
9. ES6 中的 **class** 原理是什么？







## 练习题

1. [继承](https://juejin.cn/post/6844904098941108232)





# 函数

> * this
> * arguments
> * 作用域
> * 执行上下文
> * `call()`、`apply()`、`bind()`
> * 闭包







## 面试题

1. 如何正确判断 **this**？箭头函数的 this 是什么？(掘金小册)
2. **call()、apply() 和 bind()** 的作用分别是什么？各自有什么区别？如何自己实现它们？（[掘金](https://juejin.cn/post/6844903976081555470)）





## 练习题

1. [this](https://juejin.cn/post/6844904083707396109)





