# 面试题汇总

* [前端进阶指南 ProcessOn](https://www.processon.com/view/link/61c53fb31efad45a2b42afd9#map)
* [大厂面试题每日一题](https://q.shanyue.tech/fe/)
* [56个 JavaScript 高级手写知识点](https://juejin.cn/post/7023906112843808804#comment)



# 手写题

* [x] 防抖和节流
* [x] 数组去重（三种方式）
* [x] call()、apply() 和 bind()
* [x] Promise
* [x] new
* [x] instanceof





# 面向对象

> * 构造函数
> * 原型（`prototype`）
> * 原型对象
> * 实例
> * 隐式原型（`[[Prototype]]` / `__proto__`）
> * 原型链
> * `instanceof`
> * `new`
> * 继承
> * `Object.create()`



## 名词

**实例/对象（引用类型的实例和自定义类型的实例）身上默认可以使用的属性和方法**

> `var instance = new Object()`
>
> `instance.`

1. `__proto__`

2. `constructor`（原型对象属性）

3. `hasOwnProperty`（原型对象方法，继承自 Object）

4. `isPrototypeOf`（原型对象方法，继承自 Object）

5. `propertyIsEnumable`（原型对象方法，继承自 Object）

6. `toLocaleString`（原型对象方法，继承自 Object）

7. `toString`（原型对象方法，继承自 Object）

8. `valueOf`（原型对象方法，继承自 Object）



## 知识点

1. 面向对象（OO）语言的共同点，都有类的概念。通过类可以创建任意多个具有相同属性和方法的对象。
2. ECMAScript 中没有类的概念，因此它的**对象**也与基于类的语言中的对象有所不同。
3. ECMAScript 把对象定义为：“无序**属性**的集合，其属性可以包含基本值、对象或函数”。
4. 每个对象都是基于一个引用类型创建的，也可以是自定义类型。
5. 引用类型的值（**对象**）是引用类型的一个**实例**。
6. 引用类型是一种数据结构，可以类比为类。
7. 对象属性在创建时都带有一些**特征值**，JavaScript 通过这些特征值来定义它们的行为。
8. 属性类型：有两种类型，数据属性和访问器属性。每种属性都有一些用来描述其行为的特性。这些特性是 JavaScript 内部使用的，不可以在 JavaScript 中直接访问它们。
9. 数据属性：[[Configurable]]、[[Enumerable]]、[[Writable]] 和 [[Value]]。直接在对象上定义的属性，这四个特性都被设置为 true。
10. `Object.defineProperty()`
11. 访问器属性：[[Configurable]]、[[Enumerable]]、[[Get]] 和 [[Set]]。不能直接定义访问器属性，必须使用 `Object.defineProperty()` 来定义。
12. 读取属性的特性：`Object.getOwnPropertyDescriptor()`
13. 【*1】创建对象 -- 工厂模式。思路：1. 创建一个对象；2. 往这个对象身上添加属性；3. 返回这个对象。缺点：无法识别对象的类型。
14. 【*2】创建对象 -- 构造函数模式。思路：1. 定义一个构造函数（函数名以大写开头的函数）；2. 使用 new 操作符创建构造函数的实例。使用 new 操作符调用构造函数：1. 创建一个对象；2. 将构造函数的作用域赋给新对象（将 this 指向这个新对象）；3. 执行构造函数中的代码（为新对象添加属性）；4. 返回这个新对象（如果构造函数没有返回对象类型，则返回这个新对象，否则返回构造函数的返回值）。优点：创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型（比如 Person 类型）。缺点：为了让实例共享（功能相同的）方法，需要将方法的定义放到构造函数外部（全局作用域中），从而破坏了程序的封装性质。
15. `instanceOf` 操作符，思考：为什么使用对象字面量重写了构造函数的原型（ `构造函数.prototype`）后，`instanceof` 操作符依然有效。 `instanceof` 的原理是什么。
16. 实例身上的 constructor 属性指向该实例的构造函数。
17. 【*3】创建对象 -- 原型模式。思路：利用函数的 `prototype` 属性，将实例共享的属性和方法定义到原型对象身上。优点：实例可以共享属性和方法。缺点：由于定义在原型上的属性和方法被所有实例所共享，所以有一个实例修改了某个属性将会影响到其他实例。不可以向构造函数传递参数。
18. 【1】每个函数都有一个 `prototype`（原型）属性。这个属性是一个指针，指向一个对象（原型对象），这个对象的用途是**包含可以由特定类型的所有实例共享的属性和方法**（包括 `constructor` 属性）。所以 `prototype` 所指向的对象，就是通过调用构造函数而创建的实例对象的**原型对象**。【2】所有原型对象都会自动获得一个 `constructor` 属性，这个属性包含一个指向 prototype 属性所在函数的指针。原型对象中的其他方法，则是从 Object 继承而来的。【3】当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（`__proto__`），指向构造函数的原型对象。
19. `构造函数.prototype.isPrototypeOf(实例)`，如果 `[[Prototype]] ` 指向调用 `isPrototypeOf()` 方法的对象，那么这个方法就返回 `true`（例如：`Person.prototype.isPrototypeOf(person)`）。
20. `Object.getPrototypeOf(实例)`，该方法返回 `[[Prototype]]` 的值，利用该方法，可以方便的取得一个对象的原型对象。
21. `实例.hasOwnProperty(属性)` ，该方法可以判断属性是在实例自身还是存在于原型对象身上。
22. `in`，有两种方式使用 `in` 操作符：单独使用和在 `for-in` 循环中使用。一个属性，不管是在实例身上还是在原型对象身上，只要实例可以访问该属性，则 `in` 操作符的结果为 `true`。
23. 【1】`for-in` 循环，返回的是所有能够通过对象访问的、**可枚举**的属性。**既包括实例属性，也包括原型中的属性**。【2】`Object.keys(实例)` / `Object.keys(构造函数.prototype)` 方法，该方法可以取得对象身上所有的**可枚举的实例属性**，返回一个包含所有可枚举属性的字符串数组。【3】`Object.getOwnPropertyNames(实例)` / `Object.getOwnPropertyNames(构造函数.prototype)` 方法，该方法可以取得**所有实例属性**，无论它是否可枚举。
24. 使用一个包含所有属性和方法的对象字面量来重写整个原型对象。这种方法会出现一个问题，原型对象中的 `constructor` 属性将不再指向原来的构造函数，而是指向 Object 构造函数。可以在原型对象中显示的将 `constructor` 属性的值设置为原来的构造函数，但是这样又会出现新的问题，即 `constructor` 属性变成可枚举属性（可以通过 `for-in` 循环获取）。可以通过 `Object.defineProperty()` 方法来定义 `constructor` 属性。
25. 【*4】创建对象 -- 组合使用构造函数模式和原型模式。思路：将实例的私有属性定义在构造函数中，将需要共享的属性和方法定义在原型对象中。
26. 【*5】创建对象 -- 动态原型模式。在构造函数中检查某个应该存在的方法是否有效，来决定是否需要初始化原型。
27. 【*6】创建对象 -- 寄生构造函数模式。思路：构造函数的形式与工厂模式一模一样（手动创建一个对象，往该对象身上添加属性和方法，最后返回该对象），与工厂模式不同的是该构造函数将会使用 `new` 操作符来调用。应用：在不向原生对象的原型上添加方法的前提下，创建出具有特殊方法的实例（例如，不向 `Array.prototype` 上添加方法，但是创建出来的数组却具有特殊的方法）。
28. 【*7】创建对象 -- 稳妥构造函数模式。思路：没有公共属性，其方法不引用 `this`，不使用 `new` 调用构造函数。必须通过实例的方法才能访问到属性。
29. 【*1】继承 -- 原型链。优点：可以轻松实现继承。缺点：【1】由于使用原型链实现继承的原理是将一个原型对象作为另一个类型的实例，所以原型对象会包含另一个类型的所有属性，又因为实例指向相同的原型对象，所以实例将共享原型身上的属性和方法（如果是引用类型的属性，则会容易出错）。【2】在创建子类型的实例时，无法向超类型的构造函数传递参数。
30. 构造函数、原型和实例的关系（原型链的基本概述）：每一个构造函数都有一个 prototype 属性指向它的原型对象，原型对象内部有一个 constructor 属性指向该原型对象的构造函数，通过 new 操作符调用构造函数可以创建实例，实例内部有一个 [[Prototype]] 指针，指向原型对象。假如让原型对象等于另一个类型的实例，那么此时的原型对象将包含一个指向另一个原型对象的内部指针，另一个原型对象也会包含一个指向另一个构造函数的指针。假如另一个原型对象又是另一个类型的实例，那么上述关系依然成立，如此关系层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。
31. 【*2】继承 -- 借用构造函数（伪造对象 / 经典继承）。思路：在子类型中使用 `call` 或 `apply` “借调”超类型的构造函数。优点：实例对象可以有独立的属性和方法。可以向超类型传递参数。缺点：必须将所有方法都定义在构造函数中，失去了函数的复用性。超类型原型中的属性和方法不能被子类型使用。
32. 【*3】继承 -- 组合继承（伪经典继承）。思路：将原型链和借用构造函数的技术组合在一起。使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，即通过在原型上定义方法实现了函数的复用，又能保证每个实例都有它自己的属性。优点：【1】每个实例可以有自己属性，也可以使用相同的方法。【2】在子类型中可以向超类型传递参数。
33. 【*4】继承 -- 原型式继承。思路：定义一个工厂函数，在这个函数内部先创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型对象，最后返回这个临时类型的一个新实例。从本质上讲，这个工厂函数式对传入的对象做了一次浅复制。
34. `Object.create()` 方法，规范化了原型式继承。该方法接收两个参数，并返回一个对象。第一个参数是作为返回对象的 `[[Prototype]]` 属性所指向的原型对象，第二个参数（可选）是一个为新对象定义额外属性的对象（与 `Object.defineProperties()` 方法的第二个参数格式相同）。在传入一个参数的情况下，`Object.create()` 的行为与上述的构造函数行为相同。
35. 【*5】继承 -- 寄生式继承。思路：在原型式继承的基础上，为新创建的对象扩展对象的属性和方法。应用：在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。
36. 【*6】继承 -- 寄生组合式继承。组合式继承存在的问题：在子类型的实例和实例的原型对象上都会存在超类型构造函数内的属性。思路：利用寄生式继承仅仅让子类型的原型内部的 `[[Prototype]]` 属性指向超类型的原型对象，而不是像组合式继承那样通过 `new` 操作符调用超类型构造函数，从而避免了子类型的原型上也存在超类型构造函数中的属性。
37. `Object.setPrototypeOf(实例, 原型对象)`，该方法允许修改任意指定实例的原型。
38. `super` 是指向当前对象原型的一个指针，实际上就是 `Object.getPrototypeOf(实例)` 的值。可以在简写的方法之内使用 `super` 引用来调用对象原型上的任何方法。在多级继承中，`super` 引用依然有效。
39. 在 ES6 之前，“方法”的概念可以理解为对象的函数属性。ES6 则正式做出了定义：方法是一个拥有 `[[HomeObject]]` 内部属性的函数，此内部属性指向该方法所属的对象。任何对 `super` 的引用都会使用 `[[HomeObject]]` 属性来判断要做什么。具体步骤：【1】在 `[[HomeObject]]` 上调用 `Object.getPrototypeOf()` 来获取对原型的引用；【2】在该原型上查找同名函数；【3】创建 `this` 绑定并调用该方法。
40. 【*1】类 -- 形式。ES6 中引入了“类”的概念，但是其内部实现任然是基于原型。从形式上来看，ES6 中的类是使用 `class` 关键字声明，内部类似对象字面量的方法简写，并且方法之间不需要逗号。类中使用特殊的 `constructor()` 方法直接定义一个构造器，最好是将实例身上可能出现的自有属性全都放到 `constructor()` 构造器函数内定义。可以在类的内部随意添加方法，这些方法都会被放到实例的原型（`类名.prototype`）身上，并且这些方法都是不可枚举的。
41. 【*2】类 -- 对比 ES5 中的自定义类型声明（基于构造函数与原型链的类型声明）。相同点：【1】类声明是一个以自定义类型声明方式为基础的语法糖。【2】使用 `typeof` 运算法操作类名，会得到 "`function`" 结果，并且在类中定义的方法也同样会被添加到原型上。【3】值得注意的是，可以将自定义类型与类混合使用。差异：【1】类中所有的方法都是不可枚举的；【2】类中所有的方法都是不可以使用 `new` 操作符来调用的，因为这些方法内部都没有 `[[Construct]]` 属性；【3】调用构造器（可以理解为类名，因为在内部实现时会将 `constructor` 的名称设置的与类名同名）时，必须使用 `new` 操作符；【4】类声明不会被提升（行为与 `let` 相似）；【5】类声明中的所欲代码都自动运行在严格模式下；【6】不可以在类的内部重写类名。
42. 【*3】类 -- 类表达式、具名类表达式和作为一级公民的类。
43. 【*4】类 -- 访问器属性（注意，是属性不是方法）。直接在方法前面使用 `get` 和 `set` 关键字即可定义访问器属性，这和对象字面量中的写法非常类似。如果在 ES5 中则需要使用 `Object.defineProperty()` 方法来实现。
44. 【*5】类 -- 需计算的成员名。这和对象字面量中的形式一模一样。
45. 【*6】类 -- 生成器方法。可以在类中定义生成器方法，这样就可以生成一个自带迭代器的自定义类型。可以直接使用 `for-of` 循环迭代该实例（自定义类型本身变成了可迭代对象）。
46. 【*7】类 -- 静态成员。静态成员，即只能通过类（构造函数）访问的成员，无法通过实例访问。在 ES5 中如果想定义静态成员，可以直接将成员添加到构造函数上。在 ES6 中可以通过在任何方法或访问器属性前面使用 `static` 关键字定义静态成员。
47. 【*8】类 -- 继承。【1】使用 `extends` 关键字可以轻松的实现类的基础，基础了其他类的类被称为派生类。【2】在派生类中如果定义了构造器（`constructor()` 方法），则必须在构造器中使用 `super()` 方法调用父类的构造器。如果没有指定构造器，`super()` 方法将会被自动调用，并且会使用调用构造器创建新实例时提供的所有参数作为 `super()` 方法的参数（`super(...args)`）。这样可能会导致 `super()` 方法提供的参数与父类构造器需要接收的参数数量不符合的问题。【3】关于 `super()` 方法的几点说明：1. 只能在派生类中使用 `super()`。2. 在构造器中，必须在使用 `this` 之前调用 `super()` 方法，因为 `super()` 方法负责初始化 `this`。3. 在构造器中返回一个对象，就可以避免使用 `super()` 方法。【4】在派生类中定义同名方法即可屏蔽父类中的方法。【5】类中的静态成员也是可以被派生类所继承的。
48. 【*9】类 -- 继承（从表达式中派生类）。`extends` 关键字后面不光可以写父类的类名，也可以写一个表达式（比如函数调用，在该函数内部返回父类的类名等更复杂的功能）。
49. 【*10】类 -- 继承（继承内置对象）。ES6 中的类可以继承自内置对象（Array、ArrayBuffer、Map、Promise、RegExp、Set 和 类型化数组）。
50. 【*11】类 -- `new.target` 。【1】在方法内使用 `new.target` 可以用来判断该方法是否是使用 `new` 操作符调用的。在构造器内使用 `new.target` 可以判断该类是否是使用 `new` 操作符调用的。【2】如果在父类的构造器中使用 `new.target` ，但是实例是通过 `new` 操作符调用派生类创建的，那么父类构造器中的 `new.target` 将返回派生类的类名。【3】使用 `new.target` 的特性，可以用来创建一个静态的不可被实例化的基类。



## 面试题

1. 如何理解**原型**？如何理解原型链？(掘金小册)
2. 如何自己实现一个 **instanceof** 运算符？（掘金小册）
5. 使用 **new** 操作符时会进行哪些操作？（[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new)）
6. 如何自己实现一个 **new** 操作符？（[掘金](https://juejin.cn/post/6844903976081555470)）
7. JavaScript 中实现**继承**有哪些方式？（[掘金](https://juejin.cn/post/6844903976081555470)）
8. **ES5/ES6 继承**除了形式上还有哪些区别？
9. ES6 中的 **class** 原理是什么？



## 练习题

1. [继承](https://juejin.cn/post/6844904098941108232)



# 函数

> * this
> * arguments
> * 作用域
> * 执行上下文
> * `call()`、`apply()`、`bind()`
> * 闭包



## 知识点

1. 参数。在调用函数时，可以忽略命名参数的个数，ES 对传递的参数个数没有严格的限制。因为参数在函数内部是用一个数组来表示的，函数内部使用 `arguments` 对象来访问这个参数数组，从而获取到传递给函数的每一个参数。
2. `arguments` 是一个类（类似）数组对象，【1】可以使用方括号语法来访问 `arguments` 对象的每一个元素；【2】可以使用 `length` 属性来获取 `arguments` 对象的长度；【3】但是该对象身上并没有类似 `push()` 和 `splice()` 这样的方法。【4】没有传递值的参数将自动被设置为 `undefined`。【5】非严格模式下可以使用 `arguments` 重写命名参数的值，但是严格模式下不允许这么做。
3. ES 中的函数没有重载功能（因为函数名实际上只是一个指针，如果重复赋值，则后面的值会覆盖前面的值），但是可以通过在函数内部判断 `arguments.length` 的值来执行不同的操作，从而模拟类似重载的功能。
4. ES 中所有函数的参数都是按值传递的。如果传递给参数的是基本类型的值则会类似深拷贝，如果是引用类型的值则会类似浅拷贝。
5. 使用 `typeof` 操作符检测函数的类型时，会返回 `"function"`。
6. 【*1】执行环境与作用域。【1】执行环境，也叫作环境，定义了变量或函数有权访问的其他数据，决定了它们各自的行为；【2】变量对象，每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中（无法直接访问变量对象）；【3】环境栈，每个函数都有自己的执行环境，当函数被执行时会被推入一个环境栈中，当函数执行完毕后会被从执行栈中弹出；【4】作用域链，当代码在一个环境中执行时，会创建变量对象的一个作用域链。其用途是保证对执行环境有权访问的变量和函数的有序访问；【5】活动对象，如果执行环境是函数，则将其活动对象作为变量对象。活动对象最开始只包含 `arguments` 对象这一个变量；【6】访问规则，作用域链只能向上搜索，无法向下搜索。
7. 函数的本质。【1】ES 中函数的本质是对象；【2】每个函数都是 Function 类型的实例，所以函数也是一种引用类型；【3】函数名只是一个指向函数对象的指针。
8. 函数声明与函数表达式的区别。【1】函数声明会被提升；【2】函数表达式只有当代码执行到函数声明的位置时才会被赋值。
9. 可以将函数当做值传递给另一个参数，也可以将函数作为另一个参数的返回值。
10. 函数的**内部**属性：`arguments、this 和 caller`。【1】`arguments` 对象指向函数的参数数组。【2】`this` 是函数内部的一个特殊对象，`this` 引用的是函数执行时的环境对象。【3】函数内部的 `caller` 属性保存着调用该函数的函数的引用，如果在全局环境中调用函数，则 `caller` 的值为 `null`。
11. 深入 `this`。【1】在（浏览器的）全局环境中直接执行函数，在非严格模式下 `this` 值为 `windows`（Node.js 全局环境中值为 `global`），在严格模式下 `this` 值为 `undefined`（Node.js 中也一样）。【2】当一个对象使用点的方式去调用函数，则 `this` 的值指向该对象。【3】当使用 `call()、apply() 或 bind()` 调用函数时，则 `this` 的值为传入这些方法的第一个参数。在非严格模式下，当这些方法的第一个参数为 `this、null 或 undefined` 时，函数内部的 `this` 属性将等于 `windows` 对象。
12. 函数的属性和方法。【1】`length` 属性。该属性返回该函数的命名参数的个数。【2】`prototype` 属性。该属性不可枚举，该属性指向函数的原型对象。【3】函数的自有方法：`call()、apply() 和 bind()`。`apply()` 方法，接收两个参数，第一个参数是在其中运行函数的作用域，第二个参数是一个参数数组（可以是 `Array` 的实例，也可以是 `arguments` 对象）。`call()` 方法，接收多个参数，第一个参数是在其中运行函数的作用域，剩下的参数将作为将要运行的函数的参数传入。`bind()`方法，会创建一个函数的实例（返回一个函数），其 `this` 值将会被绑定到传给 `bind()` 函数的值。`bind()` 方法的参数形式与 `call()` 方法相同。【4】函数继承而来的方法：`toLocaleString()、toString()、valueOf() 等`。
13. 【*1】递归。一个函数通过名字调用自身。
14. 【*2】闭包。【1】概念：闭包是指有权访问另一个函数作用域中的变量的函数（内部函数）。在一个函数的内部创建（返回）一个函数（通常是匿名函数），即可创建（形成）闭包。【2】现象：这个在函数内部创建（返回）的函数，虽然被返回了，而且在其他地方被调用，但它仍然可以访问其在创建时的外层函数中的变量。【3】理解闭包的关键是理解作用域链以及作用域链有什么作用的细节。【4】闭包只能取包含函数中任意变量的最后一个值。
15. 【*3】闭包中的 `this` 值。函数在被调用时会自动取得两个**特殊变量**：`this 和 arguments`。这两个变量的特殊性体现在，内部函数在搜索这两个变量时，只会搜索到其活动对象为止。因此永远不可能直接访问外部函数中的这两个变量（如果将外部函数中的 `this` 保存在内部函数能够访问到的一个变量里，就可以让闭包访问到该对象了）。
16. 【*4】可以使用立即调用函数实现块级作用域。
17. 【*5】函数表达式中的其他概念：私有变量、静态私有变量、模块模式（增强版的单例对象（JavaScript 以对象字面量的方式创建单例对象））和增强的模块模式。
18. 【*1】函数的参数默认值，ES6 允许给函数的参数设置默认值，以便参数未被正式传递进来时使用。
19. 【*2】关于 `arguments` 对象与函数的命名参数的一些说明。【1】在 ES5 非严格模式下，`arguments` 对象会及时反映出函数具名参数的变化（`arguments` 对象始终与命名参数保持同步）。【2】在 ES5 严格模式下，`arguments` 对象无法实时反映出函数具名参数的变化。【3】在 ES6 中，`arguments` 对象也无法实时反映出函数具名参数的变化。并且 `arguments` 对象只能反映出函数具名参数的初始调用状态（假如函数的具名参数中存在默认参数，那么这些参数将不会存在于 `arguments` 对象中）。
20. 【*3】参数默认值表达式。参数默认值不光可以是普通值，也可以是表达式。【1】当参数默认值是函数时，如果是函数名，则表示是对该函数的引用。如果是函数调用，则并不会立即调用，而是等到函数被调用并且该位置的参数没有传递的情况下才会去调用参数默认值函数。【2】函数的参数默认值，后面的参数可以等于前面的参数，但是反过来不行。
21. 【*4】剩余参数。在 ES5 中如果想要使用匿名参数，那么只能通过操作 `arguments` 对象来实现，但是这些操作一般都比较麻烦。ES6 中引入了剩余参数的概念，由 `...` 和一个具名参数指定。它是包含传递给函数的剩余参数组成的一个数组（将多个独立的参数合并成一个数组）。【1】剩余参数的数量并不会通过函数的 `length` 属性表现出来。【2】剩余参数只能有一个，并且要放在所有具名参数的最后面。【3】不可以在对象的 `setter` 属性中使用剩余参数，因为对象的 `setter` 属性要求必须只能接收一个参数。
22. 【*5】扩展运算符（`...`）。将一个数组分割成独立的项传递给函数的参数。在使用扩展运算符时，也可以混入其他的值一并传递给函数的参数。
23. 【*6】函数的名称属性 `name`。方便在调试时获取有用的信息。
24. 【*7】`new.target` 元属性（非对象身上的属性）。在函数的内部有两个方法 `[[Call]] 和 [[Construct]]` 。当使用 `new` 操作符调用函数时，`[[Construct]]` 方法将会被调用，负责创建一个新的对象，并且 `new.target` 会被填入 `new` 操作符的作用目标。当正常调用函数时，`[[Call]]` 方法将会被执行，运行的代码是显示的函数体，`new.target` 的值为 `undefined`。
25. 【*8】箭头函数。【1】没有 `this、arguments、super 以及 new.target 绑定`。这些值都由包括箭头函数最近的非箭头函数决定。【2】不能使用 `new` 操作符调用箭头函数。【3】箭头函数没有原型对象。【4】可以使用 `call()、apply() 与 bind()` 方法调用箭头函数，但是无法改变箭头函数的 `this` 值。
26. 【*9】在写递归函数时可以考虑“尾调用优化”。

 

## 面试题

1. 如何正确判断 **this**？箭头函数的 this 是什么？(掘金小册)
2. **call()、apply() 和 bind()** 的作用分别是什么？各自有什么区别？如何自己实现它们？（[掘金](https://juejin.cn/post/6844903976081555470)）



## 练习题

1. [this](https://juejin.cn/post/6844904083707396109)







# 异步

> * setTimeout
> * setInterval
> * 事件回调
> * 回调函数
> * Promise
> * 迭代器
> * 生成器
> * async/await
> * Event Loop
> * 宏任务队列
> * 微任务队列



## 知识点

