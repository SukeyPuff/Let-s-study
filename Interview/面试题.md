# 面试题汇总

* [前端进阶指南 ProcessOn](https://www.processon.com/view/link/61c53fb31efad45a2b42afd9#map)
* [大厂面试题每日一题](https://q.shanyue.tech/fe/)
* [56个 JavaScript 高级手写知识点](https://juejin.cn/post/7023906112843808804#comment)



# 手写题

* [x] 防抖和节流
* [x] 数组去重（三种方式）
* [x] call()、apply() 和 bind()
* [x] Promise
* [x] new
* [x] instanceof





# 面向对象

> * 构造函数
> * 原型（`prototype`）
> * 原型对象
> * 实例
> * 隐式原型（`[[Prototype]]` / `__proto__`）
> * 原型链
> * `instanceof`
> * `new`
> * 继承
> * `Object.create()`
> * this
> * 作用域
> * 执行上下文
> * `call()`、`apply()`、`bind()`
> * 闭包



## 名词

**实例/对象（引用类型的实例和自定义类型的实例）身上默认可以使用的属性和方法**

> `var instance = new Object()`
>
> `instance.`

1. `__proto__`

2. `constructor`（原型对象属性）

3. `hasOwnProperty`（原型对象方法，继承自 Object）

4. `isPrototypeOf`（原型对象方法，继承自 Object）

5. `propertyIsEnumable`（原型对象方法，继承自 Object）

6. `toLocaleString`（原型对象方法，继承自 Object）

7. `toString`（原型对象方法，继承自 Object）

8. `valueOf`（原型对象方法，继承自 Object）







## 知识点

1. 面向对象（OO）语言的共同点，都有类的概念。通过类可以创建任意多个具有相同属性和方法的对象。
2. ECMAScript 中没有类的概念，因此它的**对象**也与基于类的语言中的对象有所不同。
3. ECMAScript 把对象定义为：“无序**属性**的集合，其属性可以包含基本值、对象或函数”。
4. 每个对象都是基于一个引用类型创建的，也可以是自定义类型。
5. 引用类型的值（**对象**）是引用类型的一个**实例**。
6. 引用类型是一种数据结构，可以类比为类。
7. 对象属性在创建时都带有一些**特征值**，JavaScript 通过这些特征值来定义它们的行为。
8. 属性类型：有两种类型，数据属性和访问器属性。每种属性都有一些用来描述其行为的特性。这些特性是 JavaScript 内部使用的，不可以在 JavaScript 中直接访问它们。
9. 数据属性：[[Configurable]]、[[Enumerable]]、[[Writable]] 和 [[Value]]。直接在对象上定义的属性，这四个特性都被设置为 true。
10. `Object.defineProperty()`
11. 访问器属性：[[Configurable]]、[[Enumerable]]、[[Get]] 和 [[Set]]。不能直接定义访问器属性，必须使用 `Object.defineProperty()` 来定义。
12. 读取属性的特性：`Object.getOwnPropertyDescriptor()`
13. 【*1】创建对象 -- 工厂模式。思路：1. 创建一个对象；2. 往这个对象身上添加属性；3. 返回这个对象。缺点：无法识别对象的类型。
14. 【*2】创建对象 -- 构造函数模式。思路：1. 定义一个构造函数（函数名以大写开头的函数）；2. 使用 new 操作符创建构造函数的实例。使用 new 操作符调用构造函数：1. 创建一个对象；2. 将构造函数的作用域赋给新对象（将 this 指向这个新对象）；3. 执行构造函数中的代码（为新对象添加属性）；4. 返回这个新对象（如果构造函数没有返回对象类型，则返回这个新对象，否则返回构造函数的返回值）。优点：创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型（比如 Person 类型）。缺点：为了让实例共享（功能相同的）方法，需要将方法的定义放到构造函数外部（全局作用域中），从而破坏了程序的封装性质。
15. `instanceOf` 操作符，思考：为什么使用对象字面量重写了构造函数的原型（ `构造函数.prototype`）后，`instanceof` 操作符依然有效。 `instanceof` 的原理是什么。
16. 实例身上的 constructor 属性指向该实例的构造函数。
17. 【*3】创建对象 -- 原型模式。思路：利用函数的 `prototype` 属性，将实例共享的属性和方法定义到原型对象身上。优点：实例可以共享属性和方法。缺点：由于定义在原型上的属性和方法被所有实例所共享，所以有一个实例修改了某个属性将会影响到其他实例。不可以向构造函数传递参数。
18. 【1】每个函数都有一个 `prototype`（原型）属性。这个属性是一个指针，指向一个对象（原型对象），这个对象的用途是**包含可以由特定类型的所有实例共享的属性和方法**（包括 `constructor` 属性）。所以 `prototype` 所指向的对象，就是通过调用构造函数而创建的实例对象的**原型对象**。【2】所有原型对象都会自动获得一个 `constructor` 属性，这个属性包含一个指向 prototype 属性所在函数的指针。原型对象中的其他方法，则是从 Object 继承而来的。【3】当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（`__proto__`），指向构造函数的原型对象。
19. `构造函数.prototype.isPrototypeOf(实例)`，如果 `[[Prototype]] ` 指向调用 `isPrototypeOf()` 方法的对象，那么这个方法就返回 `true`（例如：`Person.prototype.isPrototypeOf(person)`）。
20. `Object.getPrototypeOf(实例)`，该方法返回 `[[Prototype]]` 的值，利用该方法，可以方便的取得一个对象的原型对象。
21. `实例.hasOwnProperty(属性)` ，该方法可以判断属性是在实例自身还是存在于原型对象身上。
22. `in`，有两种方式使用 `in` 操作符：单独使用和在 `for-in` 循环中使用。一个属性，不管是在实例身上还是在原型对象身上，只要实例可以访问该属性，则 `in` 操作符的结果为 `true`。
23. 【1】`for-in` 循环，返回的是所有能够通过对象访问的、**可枚举**的属性。**既包括实例属性，也包括原型中的属性**。【2】`Object.keys(实例)` / `Object.keys(构造函数.prototype)` 方法，该方法可以取得对象身上所有的**可枚举的实例属性**，返回一个包含所有可枚举属性的字符串数组。【3】`Object.getOwnPropertyNames(实例)` / `Object.getOwnPropertyNames(构造函数.prototype)` 方法，该方法可以取得**所有实例属性**，无论它是否可枚举。
24. 使用一个包含所有属性和方法的对象字面量来重写整个原型对象。这种方法会出现一个问题，原型对象中的 `constructor` 属性将不再指向原来的构造函数，而是指向 Object 构造函数。可以在原型对象中显示的将 `constructor` 属性的值设置为原来的构造函数，但是这样又会出现新的问题，即 `constructor` 属性变成可枚举属性（可以通过 `for-in` 循环获取）。可以通过 `Object.defineProperty()` 方法来定义 `constructor` 属性。
25. 【*4】创建对象 -- 组合使用构造函数模式和原型模式。思路：将实例的私有属性定义在构造函数中，将需要共享的属性和方法定义在原型对象中。
26. 【*5】创建对象 -- 动态原型模式。在构造函数中检查某个应该存在的方法是否有效，来决定是否需要初始化原型。
27. 【*6】创建对象 -- 寄生构造函数模式。思路：构造函数的形式与工厂模式一模一样（手动创建一个对象，往该对象身上添加属性和方法，最后返回该对象），与工厂模式不同的是该构造函数将会使用 `new` 操作符来调用。应用：在不向原生对象的原型上添加方法的前提下，创建出具有特殊方法的实例（例如，不向 `Array.prototype` 上添加方法，但是创建出来的数组却具有特殊的方法）。
28. 【*7】创建对象 -- 稳妥构造函数模式。思路：没有公共属性，其方法不引用 `this`，不使用 `new` 调用构造函数。
29. 【*1】继承 -- 原型链。优点：可以轻松实现继承。缺点：【1】由于使用原型链实现继承的原理是将一个原型对象作为另一个类型的实例，所以原型对象会包含另一个类型的所有属性，又因为实例指向相同的原型对象，所以实例将共享原型身上的属性和方法（如果是引用类型的属性，则会容易出错）。【2】在创建子类型的实例时，无法向超类型的构造函数传递参数。
30. 构造函数、原型和实例的关系（原型链的基本概述）：每一个构造函数都有一个 prototype 属性指向它的原型对象，原型对象内部有一个 constructor 属性指向该原型对象的构造函数，通过 new 操作符调用构造函数可以创建实例，实例内部有一个 [[Prototype]] 指针，指向原型对象。假如让原型对象等于另一个类型的实例，那么此时的原型对象将包含一个指向另一个原型对象的内部指针，另一个原型对象也会包含一个指向另一个构造函数的指针。假如另一个原型对象又是另一个类型的实例，那么上述关系依然成立，如此关系层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。
31. 【*2】继承 -- 借用构造函数（伪造对象 / 经典继承）。思路：在子类型中使用 `call` 或 `apply` “借调”超类型的构造函数。优点：实例对象可以有独立的属性和方法。可以向超类型传递参数。缺点：必须将所有方法都定义在构造函数中，失去了函数的复用性。超类型原型中的属性和方法不能被子类型使用。
32. 【*3】继承 -- 组合继承（伪经典继承）。







## 面试题

1. 如何理解**原型**？如何理解原型链？(掘金小册)
2. 如何自己实现一个 **instanceof** 运算符？（掘金小册）
3. 如何正确判断 **this**？箭头函数的 this 是什么？(掘金小册)
4. **call()、apply() 和 bind()** 的作用分别是什么？各自有什么区别？如何自己实现它们？（[掘金](https://juejin.cn/post/6844903976081555470)）
5. 使用 **new** 操作符时会进行哪些操作？（[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new)）
6. 如何自己实现一个 **new** 操作符？（[掘金](https://juejin.cn/post/6844903976081555470)）
7. JavaScript 中实现**继承**有哪些方式？（[掘金](https://juejin.cn/post/6844903976081555470)）
8. **ES5/ES6 继承**除了形式上还有哪些区别？
9. ES6 中的 **class** 原理是什么？







## 练习题

1. [this](https://juejin.cn/post/6844904083707396109)
2. [继承](https://juejin.cn/post/6844904098941108232)

